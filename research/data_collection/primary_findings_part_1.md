# Primary Research Findings - Part 1

This document contains direct findings and key data points gathered during the research process.

## Edge-Case Functional Tests

-   **JSON Handling:**
    -   .NET's `System.Text.Json` provides options for handling JSON serialization and deserialization.
    -   `JsonSerializerOptions` can be configured for case-insensitive property matching (`PropertyNameCaseInsensitive = true`). (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/character-casing.md#_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/character-casing.md#_snippet_0))
    -   Null values can be ignored during serialization using `DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull` or `[JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)]` on properties. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/migrate-from-newtonsoft.md#_snippet_7](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/migrate-from-newtonsoft.md#_snippet_7), [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/migrate-from-newtonsoft.md#_snippet_8](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/migrate-from-newtonsoft.md#_snippet_8))
    -   Deserialization can throw `JsonException` for invalid JSON, such as properties starting with '$' in types supporting metadata or mismatched key/value pairs with specific options. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/compatibility/serialization/9.0/json-metadata-reader.md#2025-04-21_snippet_2](https://github.com/dotnet/docs/blob/main/docs/core/compatibility/serialization/9.0/json-metadata-reader.md#2025-04-21_snippet_2), [https://github.com/dotnet/docs/blob/main/docs/core/compatibility/serialization/5.0/options-honored-when-serializing-key-value-pairs.md#2025-04-21_snippet_2](https://github.com/dotnet/docs/blob/main/docs/core/compatibility/serialization/5.0/options-honored-when-serializing-key-value-pairs.md#2025-04-21_snippet_2))
    -   Handling of quoted numbers in JSON can be configured. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/invalid-json.md#2025-04-21_snippet_3](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/invalid-json.md#2025-04-21_snippet_3))
    -   Comments and trailing commas are generally invalid in standard JSON but might be handled by some parsers. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/invalid-json.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/invalid-json.md#2025-04-21_snippet_0))
    -   Serialization of null for non-nullable reference types with `RespectNullableAnnotations = true` can throw `JsonException`. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/nullable-annotations.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/nullable-annotations.md#2025-04-21_snippet_0))

-   **URI Handling:**
    -   URI handling behavior can be configured in .NET, including disabling URI redaction. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/compatibility/networking/9.0/query-redaction-events.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/core/compatibility/networking/9.0/query-redaction-events.md#2025-04-21_snippet_1), [https://github.com/dotnet/docs/blob/main/docs/core/compatibility/networking/9.0/query-redaction-logs.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/core/compatibility/networking/9.0/query-redaction-logs.md#2025-04-21_snippet_1), [https://github.com/dotnet/docs/blob/main/docs/framework/configure-apps/file-schema/network/uri-element-uri-settings.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/framework/configure-apps/file-schema/network/uri-element-uri-settings.md#2025-04-21_snippet_0))
    -   Configuration for URI handling can be done via `runtimeconfig.json` or project files.

-   **Invalid Credential Configurations:**
    -   The search results did not provide specific details on invalid credential configurations within the context of a wallet framework. This is a knowledge gap.

-   **Oversized Payloads:**
    -   The search results did not provide specific details on handling oversized payloads for JSON or URIs. This is a knowledge gap.

## Concurrency & Thread-Safety

-   **Synchronization Primitives:** .NET provides low-level synchronization primitives like `Barrier`, `CountdownEvent`, `ManualResetEventSlim`, `SemaphoreSlim`, `SpinLock`, and `SpinWait` for coordinating threads. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/data-structures-for-parallel-programming.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/data-structures-for-parallel-programming.md#2025-04-21_snippet_1))
-   **Concurrent Collections:** Thread-safe collection classes such as `BlockingCollection<T>`, `ConcurrentBag<T>`, `ConcurrentDictionary<TKey, TValue>`, `ConcurrentQueue<T>`, and `ConcurrentStack<T>` are available for efficient multi-threaded data access. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/data-structures-for-parallel-programming.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/data-structures-for-parallel-programming.md#2025-04-21_snippet_0))
-   **Thread-Safe Practices:**
    -   Using the `lock` statement is a common way to synchronize access to shared resources and prevent race conditions. (Source: [https://github.com/dotnet/docs/blob/main/docs/azure/sdk/thread-safety.md#_snippet_2](https://github.com/dotnet/docs/blob/main/docs/azure/sdk/thread-safety.md#_snippet_2))
    -   `Interlocked.CompareExchange` can be used for atomic updates of reference types, offering a more efficient alternative to locking in certain scenarios. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/threading/managed-threading-best-practices.md#2025-04-21_snippet_3](https://github.com/dotnet/docs/blob/main/docs/standard/threading/managed-threading-best-practices.md#2025-04-21_snippet_3))
    -   Thread-safe delegate invocation can be achieved using the null-conditional operator `?.`. (Source: [https://github.com/dotnet/docs/blob/main/docs/csharp/language-reference/operators/member-access-operators.md#2025-04-21_snippet_4](https://github.com/dotnet/docs/blob/main/docs/csharp/language-reference/operators/member-access-operators.md#2025-04-21_snippet_4))
    -   Azure SDK clients are generally thread-safe and can be used concurrently. (Source: [https://github.com/dotnet/docs/blob/main/docs/azure/sdk/thread-safety.md#_snippet_0](https://github.com/dotnet/docs/blob/main/docs/azure/sdk/thread-safety.md#_snippet_0))
-   **Potential Pitfalls:**
    -   Accessing or modifying non-thread-safe objects (like Azure SDK model objects or `FileStream.WriteByte`) from multiple threads without synchronization can lead to undefined behavior or data corruption. (Source: [https://github.com/dotnet/docs/blob/main/docs/azure/sdk/thread-safety.md#_snippet_1](https://github.com/dotnet/docs/blob/main/docs/azure/sdk/thread-safety.md#_snippet_1), [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism.md#2025-04-21_snippet_3](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism.md#2025-04-21_snippet_3), [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-with-plinq.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-with-plinq.md#2025-04-21_snippet_1))
    -   Deadlocks can occur in parallel loops if threads wait on each other improperly. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism.md#2025-04-21_snippet_0), [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-with-plinq.md#2025-04-21_snippet_2](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/potential-pitfalls-with-plinq.md#2025-04-21_snippet_2))
    -   Caching security checks without proper synchronization can lead to vulnerabilities. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/security/security-and-race-conditions.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/standard/security/security-and-race-conditions.md#2025-04-21_snippet_1))
    -   Unsynchronized `Dispose` methods can lead to resource cleanup issues. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/security/security-and-race-conditions.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/security/security-and-race-conditions.md#2025-04-21_snippet_0))
-   **Testing Tools:**
    -   Concurrency Visualizer can be used to profile and analyze the behavior of multi-threaded applications. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/parallel-diagnostic-tools.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/standard/parallel-programming/parallel-diagnostic-tools.md#2025-04-21_snippet_1))

## Negative & Security-Focused Tests

-   **Security Token Handling:**
    -   .NET (specifically WCF in the search results) provides mechanisms for handling various security tokens like SAML and Kerberos. (Source: [https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/how-to-use-multiple-security-tokens-of-the-same-type.md#2025-04-21_snippet_3](https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/how-to-use-multiple-security-tokens-of-the-same-type.md#2025-04-21_snippet_3), [https://github.com/dotnet/docs/blob/main/docs/framework/wcf/samples/saml-token-provider.md#2025-04-22_snippet_3](https://github.com/dotnet/docs/blob/main/docs/framework/wcf/samples/saml-token-provider.md#2025-04-22_snippet_3))
    -   Creating and managing security tokens (`BinarySecretSecurityToken`, `SamlSecurityToken`) is part of implementing security services. (Source: [https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/how-to-create-a-security-token-service.md#2025-04-21_snippet_5](https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/how-to-create-a-security-token-service.md#2025-04-21_snippet_5), [https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/how-to-create-a-security-token-service.md#2025-04-21_snippet_4](https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/how-to-create-a-security-token-service.md#2025-04-21_snippet_4))
    -   Security headers in messages can follow patterns like SignBeforeEncrypt and EncryptBeforeSign. (Source: [https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/security-protocols-version-1-0.md#2025-04-21_snippet_16](https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/security-protocols-version-1-0.md#2025-04-21_snippet_16), [https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/security-protocols-version-1-0.md#2025-04-21_snippet_22](https://github.com/dotnet/docs/blob/main/docs/framework/wcf/feature-details/security-protocols-version-1-0.md#2025-04-21_snippet_22))
-   **Secure Random Number Generation:**
    -   `System.Security.Cryptography.RandomNumberGenerator` should be used for generating cryptographically secure random numbers, not `System.Random`. (Source: [https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5394.md#2025-04-21_snippet_3](https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5394.md#2025-04-21_snippet_3))
-   **Preventing Common Vulnerabilities:**
    -   Input sanitization is crucial to prevent injection attacks like XSS. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/security/security-and-user-input.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/security/security-and-user-input.md#2025-04-21_snippet_0))
    -   Secure configuration of XML readers (`XmlResolver = null` or `XmlSecureResolver`) is necessary to prevent external entity attacks. (Source: [https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca3075.md#2025-04-21_snippet_9](https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca3075.md#2025-04-21_snippet_9))
    -   Weak key derivation methods should be avoided; secure alternatives like `GetBytes` should be used. (Source: [https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5373.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5373.md#2025-04-21_snippet_1))
    -   Certificate validation, including checking revocation lists, is important for secure communication. (Source: [https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5400.md#2025-04-21_snippet_2](https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5400.md#2025-04-21_snippet_2))
    -   Hardcoding security protocol versions should be avoided; use enumeration names instead. (Source: [https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5386.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/fundamentals/code-analysis/quality-rules/ca5386.md#2025-04-21_snippet_1))
-   **Security Auditing:**
    -   NuGet package vulnerability auditing can be configured in project files. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/compatibility/sdk/8.0/dotnet-restore-audit.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/core/compatibility/sdk/8.0/dotnet-restore-audit.md#2025-04-21_snippet_1))
-   **Certificate Management:**
    -   Tools like `dotnet dev-certs` can be used to manage development certificates. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/additional-tools/self-signed-certificates-guide.md#2025-04-21_snippet_4](https://github.com/dotnet/docs/blob/main/docs/core/additional-tools/self-signed-certificates-guide.md#2025-04-21_snippet_4))
-   **Tampered Tokens and Replayed Requests:**
    -   The search results did not provide specific guidance on testing for tampered JSON Web Tokens (JWTs) or replayed HTTP requests in a general web API context. This is a knowledge gap.
-   **CSRF/XSS Checks:**
    -   While input sanitization was mentioned, specific strategies and tools for comprehensive CSRF and XSS testing in cookie-based authentication flows were not detailed. This is a knowledge gap.
-   **FIPS-Compliant RNG:**
    -   The use of `System.Security.Cryptography.RandomNumberGenerator` aligns with the need for a cryptographically secure RNG, which is a requirement for FIPS compliance. However, specific steps or configurations to ensure FIPS compliance in the context of the wallet framework's cryptographic operations were not detailed. This is a knowledge gap.
-   **SD-JWT Selective Disclosure Edge Cases:**
    -   The search results did not provide any information on SD-JWT selective disclosure edge cases, particularly with maximum nested claims. This is a significant knowledge gap.

## Performance Benchmarks

-   **Serialization Techniques:** .NET offers various serialization methods, including `System.Text.Json`, `XmlSerializer`, and `DataContractSerializer`, each with different performance characteristics.
-   **Performance Optimization Tools:** Tools like `XmlSerializerGenerator` can be used to improve the startup performance of XML serialization. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/additional-tools/index.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/core/additional-tools/index.md#2025-04-21_snippet_0))
-   **Streaming for Large Data:** `DeserializeAsyncEnumerable` allows for efficient processing of large JSON arrays by streaming, avoiding loading the entire data into memory. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/supported-types.md#2025-04-21_snippet_2](https://github.com/dotnet/docs/blob/main/docs/standard/serialization/system-text-json/supported-types.md#2025-04-21_snippet_2))
-   **Collection Performance:** The choice of collection type (mutable vs. immutable, generic vs. non-generic) can impact performance. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/collections/index.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/collections/index.md#2025-04-21_snippet_0), [https://github.com/dotnet/docs/blob/main/docs/standard/generics.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/generics.md#2025-04-21_snippet_0))
-   **String Operations Performance:** Different methods for string manipulation (e.g., `StringTokenizer` vs. `string.Split`) can have significant performance differences. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/extensions/primitives.md#2025-04-22_snippet_5](https://github.com/dotnet/docs/blob/main/docs/core/extensions/primitives.md#2025-04-22_snippet_5))
-   **Bulk Serialization/Deserialization Benchmarking:** The search results did not provide specific guidance or examples for benchmarking the performance of bulk serialization and deserialization of a large number of records (e.g., 1000). This is a knowledge gap.
-   **High-Throughput Issuance Simulation:** The search results did not provide information or strategies for designing and implementing a simulation of high-throughput credential issuance for performance testing within the wallet framework. This is a knowledge gap.

## Compliance Scenarios

-   **Cryptography Classes:** .NET provides classes for various cryptographic operations, including digital signatures (`RSA`, `ECDsa`, `DSA`), public-key encryption (`RSA`, `ECDsa`, `ECDiffieHellman`, `DSA`), and hashing (`SHA256`, `SHA384`, `SHA512`). (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/security/cryptographic-services.md#2025-04-21_snippet_3](https://github.com/dotnet/docs/blob/main/docs/standard/security/cryptographic-services.md#2025-04-21_snippet_3), [https://github.com/dotnet/docs/blob/main/docs/standard/security/cryptographic-services.md#2025-04-21_snippet_2](https://github.com/dotnet/docs/blob/main/docs/standard/security/cryptographic-services.md#2025-04-21_snippet_2), [https://github.com/dotnet/docs/blob/main/docs/standard/security/cryptographic-services.md#2025-04-21_snippet_4](https://github.com/dotnet/docs/blob/main/docs/standard/security/cryptographic-services.md#2025-04-21_snippet_4))
-   **RSA Padding Support:** .NET supports various RSA padding modes and digest algorithms across different platforms. (Source: [https://github.com/dotnet/docs/blob/main/docs/standard/security/cross-platform-cryptography.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/standard/security/cross-platform-cryptography.md#2025-04-21_snippet_0))
-   **FIPS Mode Configuration:** .NET allows configuring behavior related to FIPS mode through `AppContextSwitchOverrides` in application configuration files. (Source: [https://github.com/dotnet/docs/blob/main/includes/migration-guide/retargeting/core/managed-cryptography-classes-do-not-throw-cryptographyexception-fips-mode.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/includes/migration-guide/retargeting/core/managed-cryptography-classes-do-throw-cryptographyexception-fips-mode.md#2025-04-21_snippet_1), [https://github.com/dotnet/docs/blob/main/includes/migration-guide/retargeting/core/managed-cryptography-classes-do-not-throw-cryptographyexception-fips-mode.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/includes/migration-guide/retargeting/core/managed-cryptography-classes-do-not-throw-cryptographyexception-fips-mode.md#2025-04-21_snippet_0))
-   **Cryptography Configuration:** Custom cryptography classes and name mappings can be configured in .NET configuration files. (Source: [https://github.com/dotnet/docs/blob/main/docs/framework/configure-apps/file-schema/cryptography/cryptonamemapping-element.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/framework/configure-apps/file-schema/cryptography/cryptonamemapping-element.md#2025-04-21_snippet_1))
-   **Data Classification and Redaction:** .NET provides features for data classification and redaction, which can be relevant for compliance requirements related to handling sensitive data. (Source: [https://github.com/dotnet/docs/blob/main/docs/core/extensions/compliance.md#2025-04-21_snippet_0](https://github.com/dotnet/docs/blob/main/docs/core/extensions/compliance.md#2025-04-21_snippet_0), [https://github.com/dotnet/docs/blob/main/docs/core/extensions/compliance.md#2025-04-21_snippet_1](https://github.com/dotnet/docs/blob/main/docs/core/extensions/compliance.md#2025-04-21_snippet_1))
-   **Compliance with Specific Standards (OID4VC, mDoc, SD-JWT):** The search results did not provide specific details on compliance requirements directly related to OID4VC, mDoc, and SD-JWT specifications, particularly concerning cryptographic algorithms and SD-JWT selective disclosure. This is a knowledge gap.
-   **FIPS Compliance Verification:** While FIPS mode configuration is mentioned, concrete steps or verification methods to ensure the wallet framework's cryptographic operations are fully compliant with FIPS standards were not detailed. This is a knowledge gap.
-   **SD-JWT Selective Disclosure Compliance:** The search results provided no information on compliance aspects of SD-JWT selective disclosure, especially regarding edge cases and testing for compliance. This is a significant knowledge gap.